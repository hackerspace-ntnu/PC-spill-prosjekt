using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public abstract class PlayerState
{
<<<<<<< HEAD
    protected const float MINIMUM_TIME_BEFORE_AIR_JUMP = 0.1f;
    protected const float JUMPING_GRAVITY_SCALE = 4f;
    protected const float WALL_SLIDE_GRAVITY_SCALE = 1f;

    public float baseGravityScale = 5; // base gravity affecting the player
    public float movementSpeed = 6;
    protected float dashSpeed = 12;
=======

    public float baseGravityScale = 5; // base gravity affecting the player
    public float movementSpeed = 5;  // Orig value: 7
>>>>>>> f87dc89c1c353beae53e1e6fa75c1d0b743f5ae9
    protected int flipGravityScale = 1;
    private float maxVelocityY = 12;
    private float maxVelocityFix;
    protected float groundJumpSpeed = 13.5f;
    protected float airJumpSpeed = 11.5f;
<<<<<<< HEAD
    protected float jumpTime;
    protected int wallTrigger;

    protected float horizontalInput; // input from controller in x-axis
    protected Vector2 targetVelocity; // for setting velocity in FixedUpdate()

    private bool grounded = false;
    private bool runFixedUpdate = true;
    protected bool hasAirJumped = false;
    protected bool hasDashed = false;
=======

    protected float horizontalInput; // input from controller in x-axis
    
>>>>>>> f87dc89c1c353beae53e1e6fa75c1d0b743f5ae9

    protected PlayerController controller;
    protected Rigidbody2D rigidBody;

    public abstract string Name { get; }
<<<<<<< HEAD
    public bool Grounded { get => grounded; set => grounded = value; }
    public bool RunFixedUpdate { get => runFixedUpdate; set => runFixedUpdate = value; }
    public int WallTrigger { get => wallTrigger; set => wallTrigger = value; }
=======
>>>>>>> f87dc89c1c353beae53e1e6fa75c1d0b743f5ae9

    public virtual void Init(PlayerController controller)
    {
        this.controller = controller;
        rigidBody = controller.GetComponent<Rigidbody2D>();
        rigidBody.gravityScale = baseGravityScale;
    }

    public virtual void Enter() {}

    public virtual void Update() {
        HandleHorizontalInput();
    }

    public virtual void FixedUpdate() {

        if (Math.Sign(rigidBody.gravityScale) == 1 && rigidBody.velocity.y <= -maxVelocityY || 
            Math.Sign(rigidBody.gravityScale) == -1 && rigidBody.velocity.y >= maxVelocityY) {
            maxVelocityFix = 0.2f;
        } else {
            maxVelocityFix = 0f;
        }

<<<<<<< HEAD
        // decreases horizontal acceleration in air while input in opposite direction of velocity
        if (!grounded && Math.Sign(targetVelocity.x) != Math.Sign(rigidBody.velocity.x)) {
            targetVelocity.x *= 0.5f;
        }

        float newVelocityX = targetVelocity.x - rigidBody.velocity.x;
        float newVelocityY = targetVelocity.y - rigidBody.velocity.y * maxVelocityFix;

        rigidBody.AddForce(new Vector2(newVelocityX, newVelocityY), ForceMode2D.Impulse);
        targetVelocity.y = 0;
=======
        float newVelocityX = controller.TargetVelocity.x - rigidBody.velocity.x;
        float newVelocityY = controller.TargetVelocity.y - rigidBody.velocity.y * (1 - maxVelocityFix);

        rigidBody.AddForce(new Vector2(newVelocityX, newVelocityY), ForceMode2D.Impulse);
        controller.TargetVelocity = Vector2.zero;
>>>>>>> f87dc89c1c353beae53e1e6fa75c1d0b743f5ae9
    }

    public virtual void Exit() {}

    protected void HandleHorizontalInput()
    {
        horizontalInput = Input.GetAxis("Horizontal");
        controller.TargetVelocity = new Vector2(horizontalInput * movementSpeed * flipGravityScale, controller.TargetVelocity.y);

        /*if (Math.Abs(Input.GetAxis("Horizontal")) <= 0.1) //Beholde?
        {
            horizontalInput = 0;
        } else if (Math.Abs(horizontalInput) <= Math.Abs(Input.GetAxis("Horizontal"))) {
            horizontalInput = Input.GetAxis("Horizontal");
            if (Math.Abs(horizontalInput) > horizontalInputRunningThreshold) {
                targetVelocity.x = Math.Sign(horizontalInput) * movementSpeed * flipGravityScale; // Set horizontalInput to max
            } else {
                targetVelocity.x = horizontalInput * movementSpeed * flipGravityScale;
            }
        } else {
            targetVelocity.x = 0;
            horizontalInput = Input.GetAxis("Horizontal");
        }*/
    }

    public virtual void Jump() { }

    public virtual void Crouch() { }
}
